<!DOCTYPE html>
<html>
<head>
  <title>WebGL Line with Round Caps and Points</title>
  <style>
    canvas { border: 1px solid black; }
  </style>
</head>
<body>
  <canvas id="glCanvas" width="800" height="600"></canvas>
  <script>
    // 获取 WebGL 上下文
    const canvas = document.getElementById('glCanvas');
    const gl = canvas.getContext('webgl');
    if (!gl) {
      alert('WebGL not supported');
    }

    // 顶点着色器
    const vsSource = `
      attribute vec2 a_position;
      attribute vec4 a_color;
      uniform mat4 u_matrix;
      varying vec2 v_position;
      varying vec4 v_color;
      void main() {
        gl_Position = u_matrix * vec4(a_position, 0.0, 1.0);
        v_position = a_position;
        v_color = a_color;
        gl_PointSize = 5.0; // 设置点大小
      }
    `;

    // 片段着色器
    const fsSource = `
      precision mediump float;
      uniform vec2 u_A;
      uniform vec2 u_B;
      uniform float u_W;
      varying vec2 v_position;
      varying vec4 v_color;
      void main() {
        vec2 AB = u_B - u_A;
        float len = length(AB);
        if (len == 0.0) {
          discard;
        }
        vec2 U = AB / len;
        vec2 AP = v_position - u_A;
        float t = dot(AP, U);
        t = clamp(t, 0.0, len);
        vec2 closest = u_A + t * U;
        float dist = length(v_position - closest);
        if (dist < u_W / 2.0) {
          gl_FragColor = v_color;
        } else {
          discard;
        }
      }
    `;

    // 创建着色器
    function createShader(gl, type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
      }
      return shader;
    }

    // 创建程序
    function createProgram(gl, vsSource, fsSource) {
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
        return null;
      }
      return program;
    }

    const program = createProgram(gl, vsSource, fsSource);
    gl.useProgram(program);

    // 获取属性和统一变量位置
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const colorLocation = gl.getAttribLocation(program, 'a_color');
    const matrixLocation = gl.getUniformLocation(program, 'u_matrix');
    const aLocation = gl.getUniformLocation(program, 'u_A');
    const bLocation = gl.getUniformLocation(program, 'u_B');
    const wLocation = gl.getUniformLocation(program, 'u_W');

    // 设置投影矩阵（正交投影）
    function createOrthoMatrix(left, right, bottom, top, near, far) {
      const lr = 1 / (left - right);
      const bt = 1 / (bottom - top);
      const nf = 1 / (near - far);
      return [
        -2 * lr, 0, 0, 0,
        0, -2 * bt, 0, 0,
        0, 0, 2 * nf, 0,
        (left + right) * lr, (top + bottom) * bt, (far + near) * nf, 1
      ];
    }

    // 线段参数
    const A = { x: 100, y: 100 }; // 起点
    const B = { x: 700, y: 500 }; // 终点
    const W = 20.0; // 线宽
    const lineColor = [1.0, 0.0, 0.0, 1.0]; // 线段颜色：红色
    const pointColor = [0.0, 0.0, 1.0, 1.0]; // 点颜色：蓝色

    // 计算几何体
    const dx = B.x - A.x;
    const dy = B.y - A.y;
    const len = Math.sqrt(dx * dx + dy * dy);
    const U = { x: dx / len, y: dy / len }; // 方向向量
    const P = { x: -U.y, y: U.x }; // 垂直向量

    // 延长端点以覆盖圆帽
    const A_prime = { x: A.x - (W / 2) * U.x, y: A.y - (W / 2) * U.y };
    const B_prime = { x: B.x + (W / 2) * U.x, y: B.y + (W / 2) * U.y };

    // 矩形顶点（P0, P1, P2, P3）
    const P0 = { x: A_prime.x + (W / 2) * P.x, y: A_prime.y + (W / 2) * P.y };
    const P1 = { x: A_prime.x - (W / 2) * P.x, y: A_prime.y - (W / 2) * P.y };
    const P2 = { x: B_prime.x + (W / 2) * P.x, y: B_prime.y + (W / 2) * P.y };
    const P3 = { x: B_prime.x - (W / 2) * P.x, y: B_prime.y - (W / 2) * P.y };

    // 线段顶点（两个三角形）
    const vertices = new Float32Array([
      P0.x, P0.y,
      P1.x, P1.y,
      P2.x, P2.y,
      P1.x, P1.y,
      P3.x, P3.y,
      P2.x, P2.y
    ]);

    // 线段颜色
    const colors = new Float32Array([
      ...lineColor, ...lineColor, ...lineColor,
      ...lineColor, ...lineColor, ...lineColor
    ]);

    // 六个点（A, B, P0, P1, P2, P3）
    const points = new Float32Array([
      A.x, A.y,
      B.x, B.y,
      P0.x, P0.y,
      P1.x, P1.y,
      P2.x, P2.y,
      P3.x, P3.y
    ]);

    // 点颜色（蓝色）
    const pointColors = new Float32Array([
      ...pointColor, ...pointColor, ...pointColor,
      ...pointColor, ...pointColor, ...pointColor
    ]);

    // 创建线段顶点缓冲区
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    const colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

    // 创建点缓冲区
    const pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);

    const pointColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, pointColors, gl.STATIC_DRAW);

    // 设置顶点属性
    gl.enableVertexAttribArray(positionLocation);
    gl.enableVertexAttribArray(colorLocation);

    // 设置投影矩阵
    const matrix = createOrthoMatrix(0, canvas.width, 0, canvas.height, -1, 1);
    gl.uniformMatrix4fv(matrixLocation, false, matrix);
    gl.uniform2f(aLocation, A.x, A.y);
    gl.uniform2f(bLocation, B.x, B.y);
    gl.uniform1f(wLocation, W);

    // 渲染
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // 绘制线段
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
    gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // 绘制六个点
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, pointColorBuffer);
    gl.vertexAttribPointer(colorLocation, 4, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.POINTS, 0, 6);
  </script>
</body>
</html>